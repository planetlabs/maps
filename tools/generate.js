import {dirname, join} from 'node:path';
import {fileURLToPath} from 'node:url';
import {ESLint} from 'eslint';
import fs from 'fs-extra';
import {resolve} from 'import-meta-resolve';
import Mustache from 'mustache';
import {LAYER, directories, ignore} from '../lib/internal/config.js';

const moduleRegex = /^[A-Z](.*)\.js$/;
const header = '// This file is generated by tools/generate.js. DO NOT EDIT.\n';
Mustache.escape = text => text;

async function getNames(dir) {
  const names = await fs.readdir(dir);
  return names.filter(name => moduleRegex.test(name));
}

async function main() {
  const toolsDir = dirname(fileURLToPath(import.meta.url));
  const templatesDir = join(toolsDir, '../templates');
  const olDir = dirname(fileURLToPath(await resolve('ol', import.meta.url)));
  const libDir = join(toolsDir, '../lib');
  const eslint = new ESLint({fix: true});

  for (const type in directories) {
    const templateData =
      header +
      String(await fs.readFile(join(templatesDir, `${type}.js.mustache`)));

    const names = await getNames(join(olDir, directories[type]));

    const details = [];
    for (const name of names) {
      const commonPath = join(directories[type], name);
      if (ignore.includes(commonPath)) {
        continue;
      }

      const importName = `OL${name.replace('.js', '')}`;
      const context = {
        importSpecifier: importName,
        importName,
        importPath: `ol/${commonPath}`,
        elementType: type,
        constructorName: name.replace('.js', ''),
      };
      details.push({commonPath, context});
    }

    // special case for ol-mapbox-style
    if (type === LAYER) {
      details.push({
        commonPath: 'layer/MapboxVector.js',
        context: {
          importSpecifier: '{MapboxVectorLayer as OLMBVectorLayer}',
          importName: 'OLMBVectorLayer',
          importPath: 'ol-mapbox-style',
          thirdParty: true,
          elementType: type,
          constructorName: 'MapboxVector',
        },
      });
    }

    for (const {commonPath, context} of details) {
      let output = Mustache.render(templateData, context);
      const outputPath = join(libDir, commonPath);
      const results = await eslint.lintText(output, {filePath: outputPath});
      if (results.length !== 1) {
        throw new Error(
          `Expected a single linter result for ${outputPath}, got ${results.length}`,
        );
      }
      const result = results[0];
      if (result.errorCount > 0) {
        throw new Error(`Unable to fix lint errors in ${outputPath}`);
      }
      if (result.output) {
        // ESLint fixed something
        output = result.output;
      }

      await fs.outputFile(outputPath, output);
    }
  }
}

main().catch(err => process.stderr.write(err.stack, () => process.exit(1)));
